{"version":3,"sources":["webpack://_N_E/./actions/setSelectedMenuItemName.js","webpack://_N_E/./actions/getStaticCategoryMovies.js","webpack://_N_E/./pages/index.js","webpack://_N_E/"],"names":["name","dispatch","type","TYPES","payload","page","getState","general","selectedMenuItemName","staticCategories","filter","element","map","id","join","tmdbAPI","TMDB_API_VERSION","response","firestoreToResult","console","log","Router","LINKS","useDispatch","useSelector","state","movies","query","useRouter","categoryName","QUERY_PARAMS","Number","useEffect","setSelectedMenuItemName","clearMovies","checkEmptyObject","initialCategoryName","initialPage","newCategoryName","STATIC_MOVIE_CATEGORIES","newPage","scroll","smooth","getStaticCategoryMovies","baseUrl","base","images","secure_base_url","rel","as","href","TMDB_API_BASE_URL","crossOrigin","loading","Loader","PageWrapper","PaddingWrapper","Header","title","subtitle","MovieList","window","__NEXT_P","push"],"mappings":"+GAeA,IAXgC,SAAAA,GAAI,OAAI,SAAAC,GAIpCA,EAHGD,EAGM,CACPE,KAAMC,KACNC,QAASJ,GAJF,CAACE,KAAMC,U,wRC4BpB,EAxBgC,SAACH,EAAMK,GAAP,0CAAgB,WAAOJ,EAAUK,GAAjB,kFACKA,IAAWC,QAAtDC,EADsC,EACtCA,qBAAsBC,EADgB,EAChBA,iBACzBD,EAFyC,iEAM5CP,EAAS,CAACC,KAAMC,OACSM,EACtBC,QAAO,SAAAC,GAAO,OAAIA,EAAQX,OAASA,KACnCY,KAAI,SAAAD,GAAO,OAAIA,EAAQE,MACvBC,KAAK,IAVoC,SAWrBC,SAAA,WAAgBC,KAAhB,WAXqB,cAWtCC,EAXsC,iBAYtChB,EAAS,CACbC,KAAMC,KACNC,SAASc,QAAkBD,GAAU,KAdK,QAgB5ChB,EAAS,CAACC,KAAMC,OAhB4B,kDAkB5CgB,QAAQC,IAAI,sCAAZ,MACAnB,EAAS,CAACC,KAAMC,KAAoBC,QAAS,KAAMa,WACnDI,eAAYC,gBApBgC,0DAAhB,yD,wCCuHhC,EArGa,WACX,IAAMrB,GAAWsB,UACXhB,GAAUiB,SAAY,SAAAC,GAAK,OAAIA,EAAMlB,WACrCmB,GAASF,SAAY,SAAAC,GAAK,OAAIA,EAAMC,UAClCC,GAAUC,iBAAVD,MAEFE,EAAeF,EAAMG,cACrBzB,EAAO0B,OAAOJ,EAAMG,YAE1BE,gBAAU,WACR,OAAO,WACL/B,GAASgC,UACThC,GAASiC,aAEV,CAACjC,KAEJ+B,gBAAU,WAER,GAAIX,0BAAyBC,iBAAmBa,OAAiBR,GAAjE,CAEA,IAAMS,EAAsBf,gBAAaS,cACnCO,EAAchB,gBAAaS,UAEjC,GAAKM,GAAwBC,EAUtB,IAAKD,GAAuBC,EAAa,OACxCC,EAAkBC,YAClBC,EAAUH,EAChBlB,QAAQC,IAAI,mGAAoGkB,EAAiBE,GACjInB,kBAAe,CACbM,OAAK,eACFG,aAAwBQ,IADtB,SAEFR,SAAoBU,GAFlB,UAKF,GAAIJ,IAAwBC,EAAa,OACxCC,EAAkBF,EAExBjB,QAAQC,IAAI,0FAA2FkB,EADvF,GAEhBjB,kBAAe,CACbM,OAAK,eACFG,aAAwBQ,IADtB,SAEFR,SALW,GAGT,UAMPX,QAAQC,IAAI,2FA/B4B,OAClCkB,EAAkBC,YAExBpB,QAAQC,IAAI,qHAAsHkB,EADlH,GAEhBjB,kBAAe,CACbM,OAAK,eACFG,aAAwBQ,IADtB,SAEFR,SALW,GAGT,SA4BR,CAAC7B,EAAU0B,KAEdK,gBAAU,YACR,iBAAC,iFACMH,GAAiBxB,EADvB,wDAGCoC,iBAAmB,CAACC,QAAQ,IAH7B,SAKOzC,GAASgC,OAAwBJ,IALxC,OAMC5B,EAAS0C,EAAwBd,EAAcxB,IANhD,0CAAD,KAQC,CAACwB,EAAcxB,EAAMJ,IAnEP,IAqEQ2C,EAAYrC,EAAQsC,KAAKC,OAA1CC,gBAER,OACE,iCACE,UAAC,UAAD,YAEE,iBACEC,IAAI,UACJC,GAAG,QAEHC,KAAI,UAAKC,KAAL,YAA0BnC,KAA1B,UACJoC,YAAY,UACd,qCAAW7C,EAAQC,qBAAnB,gBAEDkB,EAAO2B,SACN,SAACC,EAAA,EAAD,KAEA,SAACC,EAAA,EAAD,WACE,UAACC,EAAA,EAAD,YACE,SAACC,EAAA,EAAD,CACEC,MAAOnD,EAAQC,qBACfmD,SAAS,YACX,SAACC,EAAA,EAAD,CACElC,OAAQA,EACRkB,QAASA,c,sBCxHlBiB,OAAOC,SAAWD,OAAOC,UAAY,IAAIC,KAAK,CAC7C,IACA,WACE,OAAO,EAAQ,W","file":"static/chunks/pages/index-5d66a811ade6273fe112.js","sourcesContent":["\nimport * as TYPES from './types';\n\n// Set the current selected menu item (discover or genre) if is valid\nconst setSelectedMenuItemName = name => dispatch => {\n  if (!name) {\n    dispatch({type: TYPES.UNSET_SELECTED_MENU_ITEM_NAME});\n  } else {\n    dispatch({\n      type: TYPES.SET_SELECTED_MENU_ITEM_NAME,\n      payload: name\n    });\n  }\n};\n\nexport default setSelectedMenuItemName;\n","\n\nimport Router from 'next/router';\n\nimport * as TYPES from './types';\nimport { alternativeTmdbAPI as tmdbAPI, firestoreToResult } from 'services/tmdbAPI';\nimport LINKS from 'utils/constants/links';\nimport { TMDB_API_VERSION } from 'config/tmdb';\n\n// Get Popular, Top Rated, and Upcoming movies\nconst getStaticCategoryMovies = (name, page) => async (dispatch, getState) => {\n  const { selectedMenuItemName, staticCategories } = getState().general;\n  if (!selectedMenuItemName) {\n    return;\n  }\n  try {\n    dispatch({type: TYPES.SET_MOVIES_LOADING});\n    const staticCategoryId = staticCategories\n      .filter(element => element.name === name)\n      .map(element => element.id)\n      .join('');\n    const response = await tmdbAPI.get(`/${TMDB_API_VERSION}/movie`);\n    await dispatch({\n      type: TYPES.FETCH_STATIC_CATEGORY_MOVIES,\n      payload: firestoreToResult(response, true)\n    });\n    dispatch({type: TYPES.UNSET_MOVIES_LOADING});\n  } catch (error) {\n    console.log('[getStaticCategoryMovies] error => ', error);\n    dispatch({type: TYPES.INSERT_ERROR, payload: error.response});\n    Router.push(LINKS.ERROR.HREF);\n  }\n};\n\nexport default getStaticCategoryMovies;\n","/**\n * TODO:\n * https://nextjs.org/blog/next-9#automatic-partial-static-export RE: https://github.com/vercel/next.js/discussions/10874\n * Should have API abort logic when components being unmounted to avoid memory leak.\n * Should use finite states model instead of boolean loading state (at /index, /genre, /movie, /person, and /search pages).\n * Should double-check if `react-scroll` is working as expected and fix.\n */\n\nimport { useEffect } from 'react';\nimport Head from 'next/head';\nimport Router, { useRouter } from 'next/router';\nimport { useDispatch, useSelector } from 'react-redux';\nimport { animateScroll as scroll } from 'react-scroll';\n\nimport Header from 'parts/Header';\nimport PageWrapper from 'parts/PageWrapper';\nimport PaddingWrapper from 'parts/PaddingWrapper';\nimport MovieList from 'components/MovieList';\nimport Loader from 'components/UI/Loader';\nimport setSelectedMenuItemName from 'actions/setSelectedMenuItemName';\nimport getStaticCategoryMovies from 'actions/getStaticCategoryMovies';\nimport clearMovies from 'actions/clearMovies';\nimport STATIC_MOVIE_CATEGORIES from 'utils/constants/static-movie-categories';\nimport QUERY_PARAMS from 'utils/constants/query-params';\nimport LINKS from 'utils/constants/links';\nimport checkEmptyObject from 'utils/helpers/checkEmptyObject';\nimport { TMDB_API_KEY, TMDB_API_BASE_URL, TMDB_API_VERSION } from 'config/tmdb';\n\nconst Home = () => {\n  const dispatch = useDispatch();\n  const general = useSelector(state => state.general);\n  const movies = useSelector(state => state.movies);\n  const { query } = useRouter();\n\n  const categoryName = query[QUERY_PARAMS.CATEGORY];\n  const page = Number(query[QUERY_PARAMS.PAGE]);\n  \n  useEffect(() => {\n    return () => {\n      dispatch(setSelectedMenuItemName());\n      dispatch(clearMovies());\n    };\n  }, [dispatch]);\n\n  useEffect(() => {\n    // MEMO: check if query parsing has finished\n    if (Router.router.asPath !== LINKS.HOME.HREF && checkEmptyObject(query)) return;\n\n    const initialCategoryName = Router.query[QUERY_PARAMS.CATEGORY];\n    const initialPage = Router.query[QUERY_PARAMS.PAGE];\n\n    if (!initialCategoryName && !initialPage) {\n      const newCategoryName = STATIC_MOVIE_CATEGORIES[0].name;\n      const newPage = 1;\n      console.log('[Home useEffect - no initial category name & no initial page] query parameter update: newCategoryName, newPage => ', newCategoryName, newPage);\n      Router.replace({\n        query: {\n          [QUERY_PARAMS.CATEGORY]: newCategoryName,\n          [QUERY_PARAMS.PAGE]: newPage\n        }\n      });\n    } else if (!initialCategoryName && initialPage) {\n      const newCategoryName = STATIC_MOVIE_CATEGORIES[0].name;\n      const newPage = initialPage;\n      console.log('[Home useEffect - no initial category name] query parameter update: newCategoryName, newPage => ', newCategoryName, newPage);\n      Router.replace({\n        query: {\n          [QUERY_PARAMS.CATEGORY]: newCategoryName,\n          [QUERY_PARAMS.PAGE]: newPage\n        }\n      });\n    } else if (initialCategoryName && !initialPage) {\n      const newCategoryName = initialCategoryName;\n      const newPage = 1;\n      console.log('[Home useEffect - no initial page] query parameter update: newCategoryName, newPage => ', newCategoryName, newPage);\n      Router.replace({\n        query: {\n          [QUERY_PARAMS.CATEGORY]: newCategoryName,\n          [QUERY_PARAMS.PAGE]: newPage\n        }\n      });\n    } else {\n      console.log('[Home useEffect - initial category name and initial page] no query parameter update');\n    }\n  }, [dispatch, query]);\n\n  useEffect(() => {\n    (async () => {\n      if (!categoryName || !page) return;\n\n      scroll.scrollToTop({smooth: true});\n      \n      await dispatch(setSelectedMenuItemName(categoryName));\n      dispatch(getStaticCategoryMovies(categoryName, page));\n    })();\n  }, [categoryName, page, dispatch]);\n\n  const { secure_base_url: baseUrl } = general.base.images;\n\n  return (\n    <>\n      <Head>\n        {/* MEMO: inspired by https://addyosmani.com/blog/preload-hero-images/ */}\n        <link\n          rel='preload'\n          as='fetch'\n          // TODO: page is hardcoded\n          href={`${TMDB_API_BASE_URL}/${TMDB_API_VERSION}/movie`}\n          crossOrigin='true' />\n        <title>{`${general.selectedMenuItemName} Movies`}</title>\n      </Head>\n      {movies.loading ? (\n        <Loader />\n      ) : (\n        <PageWrapper>\n          <PaddingWrapper>\n            <Header\n              title={general.selectedMenuItemName}\n              subtitle='movies' />\n            <MovieList\n              movies={movies}\n              baseUrl={baseUrl} />\n          </PaddingWrapper>\n        </PageWrapper>\n      )}\n    </>\n  );\n};\n\nexport default Home;\n","\n    (window.__NEXT_P = window.__NEXT_P || []).push([\n      \"/\",\n      function () {\n        return require(\"private-next-pages/index.js\");\n      }\n    ]);\n  "],"sourceRoot":""}